use std::str;

use elliptic_curve::pkcs8::DecodePublicKey;

use tlsn_core::SignedSession;

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.
fn main() {
    // Deserialize the proof
    let proof = std::fs::read_to_string("simple_proof.json").unwrap();
    let proof: SignedSession = serde_json::from_str(proof.as_str()).unwrap();

    let SignedSession {
        // The session proof establishes the identity of the server and the commitments
        // to the TLS transcript.
        application_data,
        // The substrings proof proves select portions of the transcript, while redacting
        // anything the Prover chose not to disclose.
        signature,
    } = proof;

    // Verify the session proof against the Notary's public key
    //
    // This verifies the identity of the server using a default certificate verifier which trusts
    // the root certificates from the `webpki-roots` crate.
    signature
        .verify(application_data.as_bytes(), notary_pubkey())
        .unwrap();

    println!("Successfully verified");
}

/// Returns a Notary pubkey trusted by this Verifier
fn notary_pubkey() -> p256::PublicKey {
    let pem_file = str::from_utf8(include_bytes!(
        "../../notary/server/fixture/notary/notary.pub"
    ))
    .unwrap();
    p256::PublicKey::from_public_key_pem(pem_file).unwrap()
}
